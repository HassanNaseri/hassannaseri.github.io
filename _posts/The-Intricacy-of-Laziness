---
published: false
---
## A New Post

Most likely, you have already heard this infamous quote attributed to Bill Gates that "I choose a lazy person to do a hard job. Because a lazy person will find an easy way to do it." And also noticed  a pletora of recent research work claiming lazy people being smarter, or according to a [2015 article in the Journal of Health Psychology](https://journals.sagepub.com/doi/abs/10.1177/1359105314565827?journalCode=hpqa), "low-need-for-cognition individuals" are more physically active. However, this post is not about lazy people :D


Couple of day ago, after few hours of Python coding, I went outside to enjoy Finnish summer. I took a long walk, and had plenty of time to talk to myslef :D A monologue started with an aknowledgement that I really enjoy coding sometimes. Then a question came up, what kind of coding? I enjoy highly specialized code that solves a complex problem, for example in the areas of symbolic math, statistical programming, mathematical optimization, vectorized data processing, and machine learning. 

However, other than the problem itself, what amazes me about such coding tasks, is the multiple layers of intelligenet code translation, automation and optimization invloved. 

They involve a highly sophisticated and specilaed language of their own, inside anothe llanguage.

For example, I also enjoy writing LaTeX code to create a document.

What connects these all from programming perspective is the concept of [lazy evaluation](https://en.wikipedia.org/wiki/Lazy_evaluation). 


Lazy evaluation
AKA delayed/deferred evaluation: delays the evaluation of an expression until its value is needed
Sometimes reffered to as symbolic expressions in some mathematical contexts.

That is, a statement such as x = expression; (i.e. the assignment of the result of an expression to a variable) clearly calls for the expression to be evaluated and the result placed in x, but what actually is in x is irrelevant until there is a need for its value via a reference to x in some later expression whose evaluation could itself be deferred, though eventually the rapidly growing tree of dependencies would be pruned to produce some symbol rather than another for the outside world to see.


The ability to define control flow (structures) as abstractions instead of primitives.
The ability to define potentially infinite data structures. This allows for more straightforward implementation of some algorithms.
Performance increases by avoiding needless calculations, and error conditions in evaluating compound expressions.
Ability to simplifiy and perform transformations before evaluation
Ability to characterize and compute specfic characteristics of operations, eg. gradients
Ability to optimize for runtime performance

Lazy evaluation was introduced for lambda calculus by Christopher Wadsworth.
Delayed evaluation is used particularly in functional programming languages. 

CVX
TensorFlow
Theano
Mathematica (Wolfram Language)

-----
Functional programming
It is a declarative programming paradigm, which means programming is done with expressions[1] or declarations[2] instead of statements

Map-Reduce 
Haskel, Erlang
Pyhthon,Java lambda functions
Scala
Python 3.x

Apache Spark (Streaming)
Kafka 
Apache Hadoop

---
Lisp
R 
SQL
Perl
C++
Julia
Common declarative languages include those of database query languages (e.g., SQL, XQuery), regular expressions, logic programming, functional programming, and configuration management systems.


Dataflow programming
is a programming paradigm that models a program as a directed graph of the data flowing between operations

LabView
Lustre
Scala (with a library SynapseGrid)
Simulink
Verilog, VHDL 

API
Apache Beam
Apache Flink
SystemC
TensorFlow


----- Cons
Bookkeeping overhead
Loose control over order
Extra layer of abstraction/complexity
Maybe Debugging difficulties


